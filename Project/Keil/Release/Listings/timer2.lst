C51 COMPILER V9.60.7.0   TIMER2                                                            01/30/2026 16:24:13 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TIMER2
OBJECT MODULE PLACED IN .\Release\Objects\timer2.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\timer2.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) INC
                    -DIR(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\timer2.lst) OBJECT(.\Rel
                    -ease\Objects\timer2.obj)

line level    source

   1          #include "timer2.h"
   2          #include "power_on.h"
   3          #define TIMER2_PEROID_VAL (SYSCLK / 128 / 10000 - 1) // å‘¨æœŸå€¼=ç³»ç»Ÿæ—¶é’Ÿ/åˆ†é¢‘/é¢‘çŽ‡ - 1
   4          
   5          static volatile u16 pwm_duty_add_cnt; // ç”¨äºŽæŽ§åˆ¶pwmå¢žåŠ çš„æ—¶é—´è®¡æ•°
   6          static volatile u16 pwm_duty_sub_cnt; // ç”¨äºŽæŽ§åˆ¶pwmé€’å‡çš„æ—¶é—´è®¡æ•°
   7          
   8          volatile bit flag_is_pwm_add_time_comes = 0; // æ ‡å¿—ä½ï¼Œpwmå ç©ºæ¯”é€’å¢žæ—¶é—´åˆ°æ¥
   9          volatile bit flag_is_pwm_sub_time_comes = 0; // æ ‡å¿—ä½ï¼Œpwmå ç©ºæ¯”é€’å‡æ—¶é—´åˆ°æ¥
  10          
  11          static volatile u16 pwm_duty_change_cnt = 0; // ç”¨äºŽæŽ§åˆ¶pwmå˜åŒ–çš„æ—¶é—´è®¡æ•°ï¼ˆç”¨åœ¨æ—‹é’®è°ƒèŠ‚ç
             -š„PWMå ç©ºæ¯”ä¸­ï¼‰
  12          
  13          void timer2_config(void)
  14          {
  15   1          __EnableIRQ(TMR2_IRQn); // ä½¿èƒ½timer2ä¸­æ–­
  16   1          IE_EA = 1;              // ä½¿èƒ½æ€»ä¸­æ–­
  17   1      
  18   1          // è®¾ç½®timer2çš„è®¡æ•°åŠŸèƒ½ï¼Œé…ç½®ä¸€ä¸ªé¢‘çŽ‡ä¸º1kHzçš„ä¸­æ–­
  19   1          TMR_ALLCON = TMR2_CNT_CLR(0x1);                               // æ¸…é™¤è®¡æ•°å€¼
  20   1          TMR2_PRH = TMR_PERIOD_VAL_H((TIMER2_PEROID_VAL >> 8) & 0xFF); // å‘¨æœŸå€¼
  21   1          TMR2_PRL = TMR_PERIOD_VAL_L((TIMER2_PEROID_VAL >> 0) & 0xFF);
  22   1          TMR2_CONH = TMR_PRD_PND(0x1) | TMR_PRD_IRQ_EN(0x1);                          // è®¡æ•°ç­‰äºŽå‘¨æœŸæ—¶å
             -…è®¸å‘ç”Ÿä¸­æ–­
  23   1          TMR2_CONL = TMR_SOURCE_SEL(0x7) | TMR_PRESCALE_SEL(0x7) | TMR_MODE_SEL(0x1); // é€‰æ‹©ç³»ç»Ÿæ—¶é’Ÿï¼Œ1
             -28åˆ†é¢‘ï¼Œè®¡æ•°æ¨¡å¼
  24   1      }
  25          
  26          // å®šæ—¶å™¨ ä¸­æ–­æœåŠ¡å‡½æ•°
  27          void TIMR2_IRQHandler(void) interrupt TMR2_IRQn
  28          {
  29   1          // è¿›å…¥ä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
  30   1          __IRQnIPnPush(TMR2_IRQn);
  31   1      
  32   1          // ---------------- ç”¨æˆ·å‡½æ•°å¤„ç† -------------------
  33   1      
  34   1          // å‘¨æœŸä¸­æ–­
  35   1          if (TMR2_CONH & TMR_PRD_PND(0x1)) // çº¦100usè§¦å‘ä¸€æ¬¡ä¸­æ–­
  36   1          {
  37   2              TMR2_CONH |= TMR_PRD_PND(0x1); // æ¸…é™¤pending
  38   2      
  39   2              pwm_duty_add_cnt++;
  40   2              pwm_duty_sub_cnt++;
  41   2              pwm_duty_change_cnt++;
  42   2      
  43   2              if (pwm_duty_sub_cnt >= 13) // 1300usï¼Œ1.3ms
  44   2              // if (pwm_duty_sub_cnt >= 50)
  45   2              {
  46   3                  pwm_duty_sub_cnt = 0;
  47   3                  flag_is_pwm_sub_time_comes = 1;
  48   3              }
  49   2      
  50   2              // if (pwm_duty_add_cnt >= 133) // 13300us, 13.3ms
C51 COMPILER V9.60.7.0   TIMER2                                                            01/30/2026 16:24:13 PAGE 2   

  51   2              if (pwm_duty_add_cnt >= 13) // 1300usï¼Œ1.3ms
  52   2              {
  53   3                  pwm_duty_add_cnt = 0;
  54   3                  flag_is_pwm_add_time_comes = 1;
  55   3              }
  56   2      
  57   2      #if 1                                  // è°ƒèŠ‚PWMå ç©ºæ¯”
  58   2                                             // if (pwm_duty_change_cnt >= 10) // 1000us,1ms
  59   2                                             // if (pwm_duty_change_cnt >= 1) // 100usï¼ˆç”¨é¥æŽ§å™¨è°ƒèŠ‚ï¼Œåœ
             -¨50%ä»¥ä¸Šè°ƒèŠ‚pwmå ç©ºæ¯”çš„æ—¶å€™ï¼Œç¯å…‰ä¼šæœ‰æŠ–åŠ¨ï¼‰
  60   2                                             // if (pwm_duty_change_cnt >= 5) // 500us
  61   2                                             // if (pwm_duty_change_cnt >= 10) // x * 100us ï¼ˆç”¨é¥æŽ§å™¨è°ƒèŠ
             -‚åˆ°50%ä»¥ä¸‹pwmå ç©ºæ¯”çš„æ—¶å€™ï¼Œç¯å…‰ä¼šæœ‰æŠ–åŠ¨ï¼‰
  62   2              if (pwm_duty_change_cnt >= 20) // x * 100us ï¼ˆ ç”¨é¥æŽ§å™¨è°ƒèŠ‚æ—¶ï¼Œç¯å…‰ä¸ä¼šæœ‰æŠ–åŠ¨ï¼Œæ 
             -·æœºæœ€é«˜åŠŸçŽ‡ä¸º870W--åŠ ä¸Šé£Žæ‰‡ï¼‰
  63   2              // if (pwm_duty_change_cnt >= 30) // x * 100us ï¼ˆç”¨é¥æŽ§å™¨è°ƒèŠ‚æ—¶ï¼Œç¯å…‰ä¸ä¼šæœ‰æŠ–åŠ¨ï¼Œ
             -ä½†æ˜¯è°ƒèŠ‚æ—¶é—´è¿‡é•¿ï¼Œæ„Ÿè§‰ä¸è·Ÿæ‰‹ï¼‰
  64   2              {
  65   3      
  66   3                  pwm_duty_change_cnt = 0;
  67   3      
  68   3                  if (0 == flag_is_in_power_on) // ä¸å¤„äºŽå¼€æœºç¼“å¯åŠ¨ï¼Œæ‰ä½¿èƒ½PWMå ç©ºæ¯”è°ƒèŠ‚
  69   3                  {
  70   4                      // =================================================================
  71   4                      // pwm_channel_0                                               //
  72   4                      // =================================================================
  73   4                      if (adjust_pwm_channel_0_duty > cur_pwm_channel_0_duty)
  74   4                      {
  75   5                          cur_pwm_channel_0_duty++;
  76   5                      }
  77   4                      else if (adjust_pwm_channel_0_duty < cur_pwm_channel_0_duty)
  78   4                      {
  79   5                          cur_pwm_channel_0_duty--;
  80   5                      }
  81   4      
  82   4                      set_pwm_channel_0_duty(cur_pwm_channel_0_duty);
  83   4      
  84   4                      if (cur_pwm_channel_0_duty <= 0)
  85   4                      {
  86   5                          // å°äºŽæŸä¸ªå€¼ï¼Œç›´æŽ¥è¾“å‡º0%å ç©ºæ¯”ï¼Œå…³é—­PWMè¾“å‡ºï¼Œå¼•è„šé…ç½®ä¸ºè¾“å‡º
             -æ¨¡å¼
  87   5                          pwm_channel_0_disable();
  88   5                      }
  89   4                      else // å¦‚æžœå¤§äºŽ0
  90   4                      {
  91   5                          pwm_channel_0_enable();
  92   5                      }
  93   4      
  94   4                  } // if (0 == flag_is_in_power_on) // ä¸å¤„äºŽå¼€æœºç¼“å¯åŠ¨ï¼Œæ‰ä½¿èƒ½PWMå ç©ºæ¯”è°ƒèŠ‚
  95   3              }
  96   2      #endif // è°ƒèŠ‚PWMå ç©ºæ¯”
  97   2          }
  98   1      
  99   1          // é€€å‡ºä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 100   1          __IRQnIPnPop(TMR2_IRQn);
 101   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    314    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      6    ----
C51 COMPILER V9.60.7.0   TIMER2                                                            01/30/2026 16:24:13 PAGE 3   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
