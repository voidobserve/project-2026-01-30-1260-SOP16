C51 COMPILER V9.60.7.0   PWM                                                               01/30/2026 17:54:09 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE PWM
OBJECT MODULE PLACED IN .\Release\Objects\pwm.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\pwm.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) INCDIR
                    -(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\pwm.lst) OBJECT(.\Release\O
                    -bjects\pwm.obj)

line level    source

   1          #include "pwm.h"
   2          #include "time0.h"
   3          
   4          // ç”±æ¸©åº¦é™åˆ¶çš„PWMå ç©ºæ¯” ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è®¤ä¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   5          volatile u16 limited_pwm_duty_due_to_temp = PWM_DUTY_100_PERCENT;
   6          // ç”±äºå‘åŠ¨æœºä¸ç¨³å®šï¼Œè€Œé™åˆ¶çš„å¯ä»¥è°ƒèŠ‚åˆ°çš„å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è
             -®¤ä¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   7          volatile u16 limited_pwm_duty_due_to_unstable_engine = PWM_DUTY_100_PERCENT;
   8          
   9          volatile bit flag_is_time_to_limit_pwm = 0; // æ ‡å¿—ä½ï¼Œæ˜¯å¦åˆ°äº†é™åˆ¶å ç©ºæ¯”çš„å®šæ—¶æ—¶é—´ï¼ˆç”
             -±å®šæ—¶å™¨ç½®ä½ï¼Œç½®ä½ä¹‹åä¸æ¸…é›¶ï¼‰
  10            
  11          volatile u16 cur_pwm_channel_0_duty = 0;                          // å½“å‰è®¾ç½®çš„ã€ pwm_channle_0 çš„å
             - ç©ºæ¯”ï¼ˆåªæœ‰é¥æ§å™¨æŒ‡å®šè¦ä¿®æ”¹å®ƒçš„å€¼æˆ–æ˜¯å®šæ—¶å™¨ç¼“æ…¢è°ƒèŠ‚ï¼Œæ‰ä¼šè¢«ä¿®æ”¹ï¼‰
  12          volatile u16 expect_adjust_pwm_channel_0_duty = PWM_DUTY_100_PERCENT; // å­˜æ”¾æœŸæœ›è°ƒèŠ‚åˆ°çš„ pwm_chan
             -nle_0 å ç©ºæ¯”
  13          volatile u16 adjust_pwm_channel_0_duty = PWM_DUTY_100_PERCENT;        // pwm_channle_0 è¦è°ƒæ•´åˆ°çš„å ç
             -©ºæ¯”
  14          
  15          void pwm_init(void)
  16          {
  17   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1);                         // æ¸…ç©ºè®¡æ•°å€¼
  18   1          STMR0_PSC = STMR_PRESCALE_VAL(0);                           // é¢„åˆ†é¢‘ï¼ˆå¡«å…¥çš„å€¼èŒƒå›´ï¼š0~254ï
             -¼Œå¯¹åº”1~255åˆ†é¢‘ï¼‰
  19   1          STMR0_PRH = STMR_PRD_VAL_H((STMR0_PEROID_VAL >> 8) & 0xFF); // å‘¨æœŸå€¼
  20   1          STMR0_PRL = STMR_PRD_VAL_L((STMR0_PEROID_VAL >> 0) & 0xFF);
  21   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((0) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  22   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((0) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  23   1          STMR_PWMVALA |= STMR_0_PWMVALA(0x1);
  24   1      
  25   1          STMR_CNTMD |= STMR_0_CNT_MODE(0x1); // è¿ç»­è®¡æ•°æ¨¡å¼
  26   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1); // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  27   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1); //
  28   1          STMR_CNTEN |= STMR_0_CNT_EN(0x1);   // ä½¿èƒ½
  29   1          STMR_PWMEN |= STMR_0_PWM_EN(0x1);   // PWMè¾“å‡ºä½¿èƒ½
  30   1      
  31   1          P1_MD1 &= ~GPIO_P16_MODE_SEL(0x03);
  32   1          P1_MD1 |= GPIO_P16_MODE_SEL(0x01);
  33   1          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
  34   1      }
  35          
  36          // è®¾ç½®é€šé“0çš„å ç©ºæ¯”
  37          void set_pwm_channel_0_duty(u16 channel_duty)
  38          {
  39   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((channel_duty) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  40   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((channel_duty) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  41   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1);                          // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  42   1      }
  43          
  44          /**
  45           * @brief è·å–ç¬¬ä¸€è·¯PWMçš„è¿è¡ŒçŠ¶æ€
  46           *
  47           * @return u8 0--pwmå…³é—­ï¼Œ1--pwmå¼€å¯
C51 COMPILER V9.60.7.0   PWM                                                               01/30/2026 17:54:09 PAGE 2   

  48           */
  49          u8 get_pwm_channel_0_status(void)
  50          {
  51   1          if (STMR_PWMEN & 0x01) // å¦‚æœpwm0ä½¿èƒ½
  52   1          {
  53   2              return 1;
  54   2          }
  55   1          else // å¦‚æœpwm0æœªä½¿èƒ½
  56   1          {
  57   2              return 0;
  58   2          }
  59   1      }
  60          
  61          void pwm_channel_0_enable(void)
  62          {
  63   1          // è¦å…ˆä½¿èƒ½PWMè¾“å‡ºï¼Œåœ¨é…ç½®IOï¼Œå¦åˆ™åœ¨é€»è¾‘åˆ†æä»ªä¸Šçœ‹ä¼šæœ‰ä¸ªç¼ºå£
  64   1          STMR_PWMEN |= 0x01;                // ä½¿èƒ½PWM0çš„è¾“å‡º
  65   1          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
  66   1      }
  67          
  68          void pwm_channel_0_disable(void)
  69          {
  70   1          FOUT_S16 = GPIO_FOUT_AF_FUNC; //
  71   1          P16 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
  72   1      
  73   1          // ç›´æ¥è¾“å‡º0%çš„å ç©ºæ¯”ï¼Œå¯èƒ½ä¼šæœ‰äº›è·³åŠ¨ï¼Œéœ€è¦å°†å¯¹åº”çš„å¼•è„šé…ç½®å›è¾“å‡ºæ¨¡å¼
  74   1          STMR_PWMEN &= ~0x01; // ä¸ä½¿èƒ½PWM0çš„è¾“å‡º
  75   1      }
  76          
  77          /**
  78           * @brief æ ¹æ®ä¼ å‚ï¼ŒåŠ ä¸Šçº¿æ§è°ƒå…‰çš„é™åˆ¶ã€æ¸©åº¦è¿‡çƒ­é™åˆ¶ã€é£æ‰‡å·¥ä½œå¼‚å¸¸é™åˆ¶ï¼Œ
  79           *          è®¡ç®—æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰pwmé€šé“éƒ½æœ‰æ•ˆï¼‰
  80           *
  81           * @attention å¦‚æœåå¤è°ƒç”¨ adjust_pwm_channel_x_duty = get_pwm_channel_x_adjust_duty(adjust_pwm_chan
             -nel_x_duty);
  82           *              ä¼šå¯¼è‡´ adjust_pwm_channel_x_duty è¶Šæ¥è¶Šå°
  83           *
  84           * @param pwm_adjust_duty ä¼ å…¥çš„ç›®æ ‡å ç©ºæ¯”ï¼ˆéæœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”ï¼‰ expect_adjust_pwm_chan
             -nel_x_duty
  85           *
  86           * @return u16 æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
  87           */
  88          u16 get_pwm_channel_x_adjust_duty(u16 pwm_adjust_duty)
  89          {
  90   1          // å­˜æ”¾å‡½æ•°çš„è¿”å›å€¼ -- æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
  91   1          // æ ¹æ®è®¾å®šçš„ç›®æ ‡å ç©ºæ¯”ï¼Œæ›´æ–°ç»è¿‡æ—‹é’®é™åˆ¶ä¹‹åçš„ç›®æ ‡å ç©ºæ¯”ï¼š
  92   1          u16 tmp_pwm_duty = 0;
  93   1          u16 limited_pwm_duty_due_to_schedule = PWM_DUTY_100_PERCENT; // ç”±å®šæ—¶æ—¶é—´é™åˆ¶çš„PWMå ç©ºæ¯”
  94   1      
  95   1          if (flag_is_time_to_limit_pwm)
  96   1          {
  97   2              /*
  98   2                  ç”±äºæ—‹é’®è°ƒèŠ‚ä¼˜å…ˆçº§æœ€é«˜ï¼Œå®šæ—¶æ—¶é—´é™åˆ¶çš„PWMå ç©ºæ¯”åˆä¸å±äºå¼‚å¸¸ï¼Œ
  99   2                  è¿™é‡ŒæŠŠå¯è°ƒçš„PWMå ç©ºæ¯”ä» 0 ~ limited_max_pwm_duty å¯¹åº”çš„ç™¾åˆ†æ¯” æ˜ å°„æˆ
 100   2                  0 ~ SCHEDULE_TIME_TO_LIMIT_PWM_VAL å¯¹åº”çš„ç™¾åˆ†æ¯”
 101   2              */
 102   2              limited_pwm_duty_due_to_schedule = SCHEDULE_TIME_TO_LIMIT_PWM_VAL;
 103   2          }
 104   1      
 105   1          tmp_pwm_duty = ((u32)pwm_adjust_duty * limited_max_pwm_duty / PWM_DUTY_100_PERCENT) * limited_pwm_duty
             -_due_to_schedule / PWM_DUTY_100_PERCENT; // pwm_adjust_duty * æ—‹é’®é™åˆ¶çš„å ç©ºæ¯”ç³»æ•°
 106   1      
C51 COMPILER V9.60.7.0   PWM                                                               01/30/2026 17:54:09 PAGE 3   

 107   1          // æ¸©åº¦ã€å‘åŠ¨æœºå¼‚å¸¸åŠŸç‡ä¸ç¨³å®šã€é£æ‰‡å¼‚å¸¸ï¼Œéƒ½æ˜¯å¼ºåˆ¶é™å®šå ç©ºæ¯”
 108   1          // åˆ¤æ–­ç»è¿‡æ—‹é’®é™åˆ¶ä¹‹åçš„å ç©ºæ¯” ä¼šä¸ä¼š å¤§äº æ¸©åº¦è¿‡çƒ­ä¹‹åé™åˆ¶çš„å ç©ºæ¯”
 109   1          if (tmp_pwm_duty >= limited_pwm_duty_due_to_temp)
 110   1          {
 111   2              tmp_pwm_duty = limited_pwm_duty_due_to_temp;
 112   2          }
 113   1      
 114   1          // å¦‚æœé™åˆ¶ä¹‹åçš„å ç©ºæ¯” å¤§äº ç”±äºå‘åŠ¨æœºä¸ç¨³å®šè€Œé™åˆ¶çš„ã€å¯ä»¥è°ƒèŠ‚çš„æœ€å¤§å
             - ç©ºæ¯”
 115   1          if (tmp_pwm_duty >= limited_pwm_duty_due_to_unstable_engine)
 116   1          {
 117   2              tmp_pwm_duty = limited_pwm_duty_due_to_unstable_engine;
 118   2          }
 119   1      
 120   1          return tmp_pwm_duty; // è¿”å›ç»è¿‡çº¿æ§è°ƒå…‰é™åˆ¶ä¹‹åçš„ã€æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 121   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    254    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     10       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
