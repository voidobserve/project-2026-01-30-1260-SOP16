C51 COMPILER V9.60.7.0   ADC                                                               02/05/2026 14:54:57 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Release\Objects\adc.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\adc.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCDIR(
                    -..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\adc.lst) OBJECT(.\Release\Ob
                    -jects\adc.obj)

line level    source

   1          #include "adc.h"
   2          #include "my_config.h"
   3          #include "engine.h"
   4          
   5          // å­˜æ”¾æ¸©åº¦çŠ¶æ€çš„å˜é‡
   6          volatile u8 temp_status = TEMP_NORMAL;
   7          
   8          // USER_TO_DO éœ€è¦æ”¹æˆåˆå§‹å€¼æ˜¯æ­£å¸¸çŠ¶æ€ä¸‹çš„å€¼ï¼š
   9          volatile u16 adc_val_from_engine = U16_MAX_VAL; // å­˜æ”¾ ä»å‘åŠ¨æœºä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
  10          volatile u16 adc_val_from_knob = U16_MAX_VAL;   // å­˜æ”¾ ä»æ—‹é’®ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
  11          volatile u16 adc_val_from_temp = U16_MAX_VAL;   // å­˜æ”¾ ä»çƒ­æ•ç”µé˜»ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
  12          
  13          volatile u8 cur_adc_status = ADC_STATUS_NONE; // çŠ¶æ€æœºï¼Œè¡¨ç¤ºå½“å‰adcçš„çŠ¶æ€
  14          
  15          // adcç›¸å…³çš„å¼•è„šé…ç½®
  16          void adc_pin_config(void)
  17          {
  18   1          // P30--8è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  19   1          P3_MD0 |= GPIO_P30_MODE_SEL(0x3);
  20   1      
  21   1          // P27--9è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  22   1          P2_MD1 |= GPIO_P27_MODE_SEL(0x3);
  23   1      
  24   1          // P31--7è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  25   1          P3_PU &= ~(0x01 << 1); // å…³é—­ä¸Šæ‹‰
  26   1          P3_PD &= ~(0x01 << 1); // å…³é—­ä¸‹æ‹‰
  27   1          P3_MD0 |= GPIO_P31_MODE_SEL(0x3);
  28   1      }
  29          
  30          void adc_config(void)
  31          {
  32   1          __EnableIRQ(ADC_IRQn);    // ä½¿èƒ½ADCä¸­æ–­
  33   1          IE_EA = 1;                // ä½¿èƒ½æ€»ä¸­æ–­
  34   1          ADC_CFG1 |= (0x0F << 3) | // ADCæ—¶é’Ÿåˆ†é¢‘ä¸º16åˆ†é¢‘ï¼Œä¸ºç³»ç»Ÿæ—¶é’Ÿ/16
  35   1                      (0x01 << 0);  // ADC0 é€šé“ä¸­æ–­ä½¿èƒ½
  36   1          delay_ms(1);              // ç­‰å¾…adcç¨³å®š
  37   1      }
  38          
  39          void adc_channel_sel(const u8 adc_sel_pin)
  40          {
  41   1          switch (adc_sel_pin)
  42   1          {
  43   2          case ADC_SEL_PIN_ENGINE:
  44   2              // ADCé…ç½®
  45   2              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0x01)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹ï¼Œæ¸…é™¤é€‰æ‹
             -©çš„å‚è€ƒç”µå‹
  46   2              ADC_ACON1 |= ADC_VREF_SEL(0x5) |                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹ 4.2V (ç”¨æˆ·æ
             -‰‹å†Œè¯´æœªæ ¡å‡†)
  47   2                           ADC_TEN_SEL(0x3);                           /* å…³é—­æµ‹è¯•ä¿¡å· */
  48   2              ADC_ACON0 = ADC_CMP_EN(0x1) |                            // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
  49   2                          ADC_BIAS_EN(0x1) |                           // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
  50   2                          ADC_BIAS_SEL(0x1);                           // åç½®ç”µæµï¼š1x
  51   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x17) |                       // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x17--P2
C51 COMPILER V9.60.7.0   ADC                                                               02/05/2026 14:54:57 PAGE 2   

             -7ï¼‰
  52   2                         ADC_EXT_SEL(0x0);                             // é€‰æ‹©å¤–éƒ¨é€šé“
  53   2              break;
  54   2              // ===============================================================================================
             -==
  55   2          case ADC_SEL_PIN_KNOB:                 // æ£€æµ‹æ—‹é’®è°ƒå…‰
  56   2              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹ã€æ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
  57   2              ADC_ACON1 |= ADC_VREF_SEL(0x6) |   // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹VCCA
  58   2                           ADC_TEN_SEL(0x3);     // å…³é—­æµ‹è¯•ä¿¡å·
  59   2              ADC_ACON0 = ADC_CMP_EN(0x1) |      // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
  60   2                          ADC_BIAS_EN(0x1) |     // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
  61   2                          ADC_BIAS_SEL(0x1);     // åç½®ç”µæµï¼š1x
  62   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x19) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x19--P31ï¼‰
  63   2                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  64   2              break;
  65   2              // ===============================================================================================
             -==
  66   2          case ADC_SEL_PIN_TEMP:                                                       // é‡‡é›†çƒ­æ•ç”µé˜»å¯¹å
             -º”çš„ç”µå‹çš„å¼•è„š
  67   2              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0) | ADC_INREF_SEL(0)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå
             -‹ï¼Œæ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
  68   2              ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå
             -‹VCCA
  69   2                           ADC_TEN_SEL(0x3);                                           // å…³é—­æµ‹è¯•ä¿¡å·
  70   2              ADC_ACON0 = ADC_CMP_EN(0x1) |                                            // æ‰“å¼€ADCä¸­çš„CMPä½¿è
             -ƒ½ä¿¡å·
  71   2                          ADC_BIAS_EN(0x1) |                                           // æ‰“å¼€ADCåç½®ç”µæµè
             -ƒ½ä½¿ä¿¡å·
  72   2                          ADC_BIAS_SEL(0x1);                                           // åç½®ç”µæµï¼š1x
  73   2      
  74   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x18) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x18--P30ï¼‰
  75   2                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  76   2              break;
  77   2              // ===============================================================================================
             -==
  78   2          default:
  79   2              break;
  80   2          }
  81   1      
  82   1          ADC_CFG0 |= ADC_CHAN0_EN(0x1) | // ä½¿èƒ½é€šé“0è½¬æ¢
  83   1                      ADC_EN(0x1);        // ä½¿èƒ½A/Dè½¬æ¢
  84   1      }
  85          
  86          // ä»å¼•è„šä¸Šé‡‡é›†æ»¤æ³¢åçš„ç”µå‹å€¼,å‡½æ•°å†…éƒ¨ä¼šå°†é‡‡é›†åˆ°çš„adè½¬æ¢æˆå¯¹åº”çš„ç”µå‹å€¼
  87          u32 get_voltage_from_pin(void)
  88          {
  89   1          // 4095ï¼ˆadcè½¬æ¢åï¼Œå¯èƒ½å‡ºç°çš„æœ€å¤§çš„å€¼ï¼‰ * 0.0012 == 4.914ï¼Œçº¦ç­‰äº5Vï¼ˆVCCï¼‰
  90   1          return adc_val_from_temp * 12 / 10; // å‡è®¾æ˜¯4095ï¼Œ4095 * 12/10 == 4915mV
  91   1      }
  92          
  93          // æ¸©åº¦æ£€æµ‹åŠŸèƒ½
  94          void temperature_scan(void)
  95          {
  96   1          volatile u32 voltage = 0; // å­˜æ”¾adcé‡‡é›†åˆ°çš„ç”µå‹ï¼Œå•ä½ï¼šmV
  97   1      
  98   1          // å¦‚æœå·²ç»è¶…è¿‡75æ‘„æ°åº¦ä¸”è¶…è¿‡5minï¼Œä¸ç”¨å†æ£€æµ‹8è„šçš„ç”µå‹ï¼Œç­‰å¾…ç”¨æˆ·æ’æŸ¥åŸå›
             - ï¼Œå†é‡å¯ï¼ˆé‡æ–°ä¸Šç”µï¼‰
  99   1          if (TEMP_75_5_MIN == temp_status)
 100   1          {
 101   2              return;
 102   2          }
 103   1      
C51 COMPILER V9.60.7.0   ADC                                                               02/05/2026 14:54:57 PAGE 3   

 104   1          voltage = get_voltage_from_pin(); // é‡‡é›†çƒ­æ•ç”µé˜»ä¸Šçš„ç”µå‹
 105   1          if (voltage >= (u32)U16_MAX_VAL * 12 / 10)
 106   1          {
 107   2              // å¦‚æœè¿˜æ²¡æœ‰é‡‡é›†åˆ°æ•°æ®ï¼Œadc_val_from_temp == U16_MAX_VALï¼Œç›´æ¥è¿”å›
 108   2              // printf("adc tmp not ready\n");
 109   2              return;
 110   2          }
 111   1      
 112   1          // å¦‚æœä¹‹å‰çš„æ¸©åº¦ä¸ºæ­£å¸¸ï¼Œæ£€æµ‹æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦ï¼ˆÂ±5æ‘„æ°åº¦ï¼‰
 113   1          if (TEMP_NORMAL == temp_status)
 114   1          {
 115   2              // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è¦å°äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å
             -€¼ï¼‰
 116   2              static volatile u8 cnt = 0;
 117   2              if (voltage < VOLTAGE_TEMP_75) // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è¦å°
             -äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å€¼ï¼‰
 118   2              {
 119   3                  cnt++;
 120   3              }
 121   2              else
 122   2              {
 123   3                  cnt = 0;
 124   3              }
 125   2      
 126   2              if (cnt >= 10)
 127   2              {
 128   3                  cnt = 0;
 129   3                  // æµ‹è¯•çš„æ—¶å€™ï¼Œå¦‚æœå¼•è„šæ‚¬ç©ºï¼Œå¯èƒ½ä¼šæ‰§è¡Œä¸åˆ°è¿™é‡Œï¼š
 130   3                  temp_status = TEMP_75; // çŠ¶æ€æ ‡å¿—è®¾ç½®ä¸ºè¶…è¿‡75æ‘„æ°åº¦   USER_TO_DO  åœ¨æµ‹è¯•æ—¶ä¼š
             -å±è”½æ‰ï¼Œéœ€è¦æ£€æŸ¥ä¸€ä¸‹
 131   3              }
 132   2              else
 133   2              {
 134   3                  temp_status = TEMP_NORMAL;
 135   3              }
 136   2      
 137   2              return; // å‡½æ•°è¿”å›ï¼Œè®©è°ƒèŠ‚å ç©ºæ¯”çš„å‡½æ•°å…ˆè¿›è¡Œè°ƒèŠ‚
 138   2          }
 139   1          else if (TEMP_75 == temp_status)
 140   1          {
 141   2              // å¦‚æœä¹‹å‰çš„æ¸©åº¦è¶…è¿‡75æ‘„æ°åº¦
 142   2              static bit tmr1_is_open = 0;
 143   2      
 144   2              if (0 == tmr1_is_open)
 145   2              {
 146   3                  tmr1_is_open = 1;
 147   3                  tmr1_cnt = 0;
 148   3                  tmr1_enable(); // æ‰“å¼€å®šæ—¶å™¨ï¼Œå¼€å§‹è®°å½•æ˜¯å¦å¤§äº75æ‘„æ°åº¦ä¸”è¶…è¿‡ä¸€å®šæ—¶é—´
 149   3              }
 150   2      
 151   2              // å¦‚æœè¶…è¿‡75æ‘„æ°åº¦å¹¶ä¸”è¿‡äº†5minï¼Œå†æ£€æµ‹æ¸©åº¦æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦
 152   2              if (tmr1_cnt >= (u32)TMR1_CNT_5_MINUTES)
 153   2              {
 154   3                  static volatile u8 cnt = 0;
 155   3      
 156   3                  if (voltage < VOLTAGE_TEMP_75) // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è
             -¦å°äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å€¼ï¼‰
 157   3                  {
 158   4                      cnt++;
 159   4                  }
 160   3                  else
 161   3                  {
C51 COMPILER V9.60.7.0   ADC                                                               02/05/2026 14:54:57 PAGE 4   

 162   4                      cnt = 0;
 163   4                  }
 164   3      
 165   3                  if (cnt >= 10)
 166   3                  {
 167   4                      cnt = 0;
 168   4                      temp_status = TEMP_75_5_MIN; // çŠ¶æ€æ ‡å¿—è®¾ç½®ä¸ºè¶…è¿‡75æ‘„æ°åº¦ä¸”è¶…è¿‡5min
 169   4                      tmr1_disable();              // å…³é—­å®šæ—¶å™¨
 170   4                      tmr1_cnt = 0;                // æ¸…ç©ºæ—¶é—´è®¡æ•°å€¼
 171   4                      tmr1_is_open = 0;
 172   4                  }
 173   3                  else
 174   3                  {
 175   4                      temp_status = TEMP_75;
 176   4                  }
 177   3      
 178   3                  return;
 179   3              }
 180   2          }
 181   1      }
 182          
 183          // æ ¹æ®æ¸©åº¦ï¼ˆç”µå‹å€¼æ‰«æï¼‰æˆ–9è„šçš„çŠ¶æ€æ¥è®¾å®šå ç©ºæ¯”
 184          void set_duty(void)
 185          {
 186   1          // å¦‚æœæ¸©åº¦æ­£å¸¸ï¼Œæ ¹æ®9è„šçš„çŠ¶æ€æ¥è°ƒèŠ‚PWMå ç©ºæ¯”
 187   1          if (TEMP_NORMAL == temp_status)
 188   1          {
 189   2              if (flag_is_time_to_check_engine)
 190   2              {
 191   3                  flag_is_time_to_check_engine = 0; 
 192   3                  according_pin9_to_adjust_pwm(); 
 193   3              }
 194   2          }
 195   1          else if (TEMP_75 == temp_status)
 196   1          {
 197   2              limited_pwm_duty_due_to_temp = PWM_DUTY_50_PERCENT; // å°†pwmå ç©ºæ¯”é™åˆ¶åˆ°æœ€å¤§å ç©ºæ¯”çš„ 
             -50%
 198   2          }
 199   1          else if (TEMP_75_5_MIN == temp_status)
 200   1          {
 201   2              limited_pwm_duty_due_to_temp = PWM_DUTY_25_PERCENT; // å°†pwmå ç©ºæ¯”é™åˆ¶åˆ°æœ€å¤§å ç©ºæ¯”çš„ 
             -25%
 202   2          }
 203   1      }
 204          
 205          void ADC_IRQHandler(void) interrupt ADC_IRQn
 206          {
 207   1          // è¿›å…¥ä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 208   1          __IRQnIPnPush(ADC_IRQn);
 209   1      
 210   1          // ---------------- ç”¨æˆ·å‡½æ•°å¤„ç† -------------------
 211   1          if (ADC_STA & ADC_CHAN0_DONE(0x01))
 212   1          {
 213   2              volatile u16 adc_val = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4); // å…ˆæ¥æ”¶adå€¼
 214   2              ADC_STA |= ADC_CHAN0_DONE(0x01);                              // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
 215   2      
 216   2              if (ADC_STATUS_SEL_ENGINE == cur_adc_status)
 217   2              {
 218   3                  // æ›´æ–°å‘åŠ¨æœºæ£€æµ‹ä¸€ç«¯çš„adå€¼
 219   3      
 220   3                  static u8 i = 0; // adcé‡‡é›†æ¬¡æ•°çš„è®¡æ•°
 221   3                  static volatile u32 g_tmpbuff = 0;
C51 COMPILER V9.60.7.0   ADC                                                               02/05/2026 14:54:57 PAGE 5   

 222   3                  static volatile u16 g_adcmax = 0;
 223   3                  static volatile u16 g_adcmin = 0xFFFF;
 224   3      
 225   3                  if (i < 20)
 226   3                  {
 227   4                      i++;
 228   4      
 229   4                      if (i >= 2) // ä¸¢å¼ƒå‰ä¸¤æ¬¡é‡‡æ ·å€¼
 230   4                      {
 231   5                          if (adc_val > g_adcmax)
 232   5                              g_adcmax = adc_val; // æœ€å¤§
 233   5                          if (adc_val < g_adcmin)
 234   5                              g_adcmin = adc_val; // æœ€å°
 235   5                          g_tmpbuff += adc_val;
 236   5                      }
 237   4      
 238   4                      if (i < 20)
 239   4                          ADC_CFG0 |= 0x01 << 0; // å¼€å¯adc0è½¬æ¢
 240   4                  }
 241   3      
 242   3                  if (i >= 20)
 243   3                  {
 244   4                      adc_val_from_engine = (g_tmpbuff >> 4); // é™¤ä»¥16ï¼Œå–å¹³å‡å€¼
 245   4                      cur_adc_status = ADC_STATUS_SEL_ENGINE_DONE;
 246   4      
 247   4                      // é‡æ–°åˆå§‹åŒ–ä½¿ç”¨åˆ°çš„å˜é‡ï¼š
 248   4                      i = 0;
 249   4                      g_adcmax = 0;
 250   4                      g_adcmin = 0xFFFF;
 251   4                      g_tmpbuff = 0;
 252   4                      // printf("1 engine scan done\n");
 253   4                  }
 254   3              }
 255   2              else if (ADC_STATUS_SEL_KNOB == cur_adc_status)
 256   2              {
 257   3                  // æ›´æ–°æ—‹é’®æ£€æµ‹ä¸€ç«¯çš„adå€¼
 258   3                  adc_val_from_knob = adc_val;
 259   3                  // printf("2 knob scan done\n");
 260   3              }
 261   2              else if (ADC_STATUS_SEL_GET_TEMP == cur_adc_status)
 262   2              {
 263   3                  // æ›´æ–°çƒ­æ•ç”µé˜»æ£€æµ‹ä¸€ç«¯çš„adå€¼
 264   3                  adc_val_from_temp = adc_val;
 265   3                  // printf("3 temp scan done\n");
 266   3              }
 267   2          }
 268   1      
 269   1          // é€€å‡ºä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 270   1          __IRQnIPnPop(ADC_IRQn);
 271   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    724    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     19       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
